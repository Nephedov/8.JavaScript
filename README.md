# «Декораторы»

## Решения
 * <a href="https://github.com/Nephedov/bjs-2-homeworks/blob/bjs-53/8.decorators/task.js">task.js</a> - код с реализованными функциями.

<a href="https://github.com/Nephedov/bjs-2-homeworks/tree/bjs-53/8.decorators">Репозиторий</a> с заданием и тестами.
Запуск через <a href="https://github.com/Nephedov/bjs-2-homeworks/blob/bjs-53/8.decorators/index.html">index.html</a>.

## Что было сделано
* Написан кэширующий декоратор который:
  * Принимает на вход функцию с аргументами.
  * Хэширует аргументы и создает объект, где - хеш-ключ, результат выполнения функции-значение.
  * При повторном вызове декорировнной функции с теми же аргументами - результат выполнения выводит из кэша.
  * Кэширует 5 последних различных вызовов.
* Написан debounce декоратор который:
  * Принимает на вход функцию с аргументами.
  * Выполняет первый синхронный вызов декорированной функции и запускает таймер.
  * Обновляет таймер при повторном вызове декорированной функции до истечения таймера.
  * Считает количесво вызовов декоратора и декорированной функции.
* Решение задания опубликовано в Github Pages.

---
---


### Описание Задания 1. Усовершенствовать кеширующий декоратор

Напишите усовершенствованный кеширующий декоратор `cachingDecoratorNew`, аналогичный рассмотренному на лекции, так, чтобы он кешировал только **последние пять различных** вызовов функции, то есть чтобы кеш мог хранить только пять значений.

Чтобы тесты выполнялись, функция должна возвращать следующие строки(!) «Вычисляем: 10» для первого вызова (10 для примера) и «Из кеша: 10» — для повторного. Подробнее смотрите в файле [tests.js](./tests.js).

Для вычисления хеша нужно использовать алгоритм хеширования [MD5](https://ru.wikipedia.org/wiki/MD5). Для его применения в файл с тестами была подключена библиотека [js-md5](https://github.com/emn178/js-md5). То есть алгоритм MD5 применим в любой области видимости файлов скриптов, подключенных к странице с тестами.

### Описание Задания 2. Декоратор debounce с моментальным вызовом и подсчётом количества вызовов

Усовершенствуйте рассмотренный на лекции debounce декоратор, добавив три дополнительные фичи:

1. Первый вызов происходил моментально, а следующий не раньше, чем через интервал времени, причём интервал должен задаваться в момент применения декоратора к функции. [Дополнительная статья про debouncing и throttling](https://techrocks.ru/2021/05/31/throttling-and-debouncing-explained/).
2. Усовершенствуйте декоратор так, чтобы в свойстве `count` декорированной функции хранилось количество её вызовов. Для решения используйте подход, который был применён в лекции для декоратора-шпиона. 
3. Усовершенствуйте декоратор так, чтобы в свойстве `allCount` декорированной функции хранилось количество вызовов декоратора. Для решения используйте подход, который был применён в лекции для декоратора-шпиона. 
